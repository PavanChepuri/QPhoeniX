#include "UI/mainwindow.h"
#include "ui_mainWindow.h" // Verify exact filename generated by Qt UIC
#include "UI/LoginDialog.h"
#include "Network/kiteconnectapi.h"
#include "Data/datamanager.h"
#include "Utils/configurationmanager.h"
#include "Data/DataStructures/InstrumentData.h"
#include "Utils/marketcalendar.h"

#include <QDebug>
#include <QUrl>
#include <QMessageBox>
#include <QStandardItemModel>
#include <QDateTime>
#include <QVariant>
#include <algorithm> // Needed for std::sort
#include <QTimer> // Include QTimer for singleShot
#include <QLocale> // Needed for currency formatting
#include <QStatusBar> // Include for QStatusBar

const int API_REQUEST_DELAY_MS = 500;


// Constructor
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , m_loginDialog(nullptr)
    , m_kiteApi(nullptr)
    , m_dataManager(nullptr)
    , m_availableFunds(0.0) // Initialize member
{
    ui->setupUi(this);
    this->setWindowTitle("QphoeniX Trading Application");

    // --- Initialization ---
    ConfigurationManager* configMgr = ConfigurationManager::instance();
    m_dataManager = DataManager::instance();

    if (!configMgr || !m_dataManager) {
        qCritical() << "Failed to get Singleton instance(s)! Application cannot proceed.";
        QMessageBox::critical(this, "Initialization Error", "Failed to initialize core components (DataManager/ConfigurationManager).");
        if (ui && ui->centralwidget) { ui->centralwidget->setEnabled(false); }
        ui->loginButton->setEnabled(false);
        return;
    }
    qDebug() << "DataManager instance obtained in MainWindow.";

    // Setup UI Elements
    populateIntervalCombo();
    ui->instrumentComboBox->setEnabled(false);
    ui->intervalComboBox->setEnabled(false);

    // Connect UI signals
    connect(ui->loginButton, &QPushButton::clicked, this, &MainWindow::onLoginClicked);
    connect(ui->instrumentComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::onInstrumentSelected);
    connect(ui->intervalComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::onIntervalSelected);

    // Connect DataManager signals
    connect(m_dataManager, &DataManager::allInstrumentsDataUpdated, this, &MainWindow::onDataManagerReady);

    qDebug() << "MainWindow initialized (pending KiteAPI setup).";
    // Set initial UI state for user/funds labels and status bar
    resetUserInfo(); // Clear stored info and update UI
    showStatusMessage("Ready.", 3000); // Show ready message briefly
}

// Destructor
MainWindow::~MainWindow()
{
    delete ui;
}

// Setter for KiteConnectAPI instance (called from main.cpp)
void MainWindow::setKiteConnectAPI(KiteConnectAPI *api) {
    if (!api) {
        qCritical() << "MainWindow::setKiteConnectAPI received a null pointer!";
        QMessageBox::critical(this, "Setup Error", "API connection object is missing.");
        if (ui && ui->centralwidget) { ui->centralwidget->setEnabled(false); }
        ui->loginButton->setEnabled(false);
        return;
    }
    if (m_kiteApi == api) return;
    if (m_kiteApi) { qWarning() << "MainWindow::setKiteConnectAPI called when an API object was already set. Replacing."; }

    m_kiteApi = api;
    qDebug() << "KiteConnectAPI instance set in MainWindow.";

    // Setup connections related to KiteAPI now that it's valid
    setupConnections();

    // Check API key status after API object is set
    ConfigurationManager* configMgr = ConfigurationManager::instance();
    bool keysOk = (configMgr && !configMgr->getApiKey().isEmpty() && !configMgr->getApiSecret().isEmpty());
    ui->loginButton->setEnabled(keysOk);
    if (!keysOk) {
         // *** MODIFIED *** Use showStatusMessage
         showStatusMessage("ERROR: API Key/Secret not found in configuration!", 5000);
    } else {
         // *** MODIFIED *** Use showStatusMessage
         showStatusMessage("Ready. Please log in.", 3000);
    }
}

// Sets up signal/slot connections between components
void MainWindow::setupConnections() {
    if (!m_kiteApi || !m_dataManager) { /* ... handle null ... */ return; }
    qDebug() << "Setting up API and Data signal/slot connections...";

    // --- KITE API -> MAINWINDOW Connections ---
    connect(m_kiteApi, &KiteConnectAPI::requiresUserLoginRedirect, this, &MainWindow::onRedirectUserForLogin, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::sessionGenerated, this, &MainWindow::onLoginSuccessful, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::sessionGenerationFailed, this, &MainWindow::onLoginFailed, Qt::UniqueConnection); // Connect to the single onLoginFailed
    connect(m_kiteApi, &KiteConnectAPI::userProfileReceived, this, &MainWindow::onUserProfileReceived, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::userMarginsReceived, this, &MainWindow::onUserMarginsReceived, Qt::UniqueConnection);

    // Connect failure signals using lambdas WITHOUT UniqueConnection to avoid warnings
    connect(m_kiteApi, &KiteConnectAPI::userProfileFailed, this,
            [this](const QString& error){ this->onProfileOrMarginsFailed("Profile", error); } /* Removed Qt::UniqueConnection */ );
    connect(m_kiteApi, &KiteConnectAPI::userMarginsFailed, this,
            [this](const QString& error){ this->onProfileOrMarginsFailed("Margins", error); } /* Removed Qt::UniqueConnection */ );

    connect(m_kiteApi, &KiteConnectAPI::instrumentsFetched, this, &MainWindow::onInstrumentsFetched, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::instrumentsFetchFailed, this, &MainWindow::onInstrumentsFetchFailed, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::historicalDataReceived, this, &MainWindow::onHistoricalDataReceived, Qt::UniqueConnection);
    connect(m_kiteApi, &KiteConnectAPI::historicalDataFailed, this, &MainWindow::onHistoricalDataFailed, Qt::UniqueConnection);

    // --- DATAMANAGER -> KITEAPI Connections ---
    connect(m_dataManager, &DataManager::fetchHistoricalDataRequested, m_kiteApi, &KiteConnectAPI::fetchHistoricalData, Qt::UniqueConnection);
    // --- KITEAPI -> DATAMANAGER Connections ---
    connect(m_kiteApi, &KiteConnectAPI::historicalDataReceived, m_dataManager, &DataManager::onHistoricalDataReceived, Qt::UniqueConnection);
}

// --- UI Action Slots ---

// Slot for the Login button click
void MainWindow::onLoginClicked() {
    if (!m_kiteApi) { /* ... handle null ... */ return; }
    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Initiating login...", 3000);
    ui->loginButton->setEnabled(false);
    m_kiteApi->login();
}

// Slot for Instrument ComboBox selection change
void MainWindow::onInstrumentSelected(int index) {
    Q_UNUSED(index);
    if (ui->instrumentComboBox->currentIndex() < 0) return;
    QString token = ui->instrumentComboBox->currentData().toString();
    qDebug() << "Selected Instrument: " << ui->instrumentComboBox->currentText() << " Token: " << token;
    if (!token.isEmpty()) {
        updateChart();
    }
}

// Slot for Interval ComboBox selection change
void MainWindow::onIntervalSelected(int index) {
    Q_UNUSED(index);
    if (ui->intervalComboBox->currentIndex() < 0) return;
    QString interval = ui->intervalComboBox->currentData().toString();
    qDebug() << "Selected Interval:" << interval;
    if (!interval.isEmpty()) {
        updateChart();
    }
}


// --- UI Update Slots ---

// Updates the instrument combo box (called from onDataManagerReady)
void MainWindow::updateInstrumentsTable() {
    qDebug() << "MainWindow::updateInstrumentsTable called";
    populateInstrumentCombo(); // Fill combo box from local filtered map
    bool hasInstruments = (ui->instrumentComboBox->count() > 0);
    ui->instrumentComboBox->setEnabled(hasInstruments);
    ui->intervalComboBox->setEnabled(hasInstruments);
    if (hasInstruments) {
        ui->instrumentComboBox->setCurrentIndex(0);
    } else {
        qWarning() << "Instrument combo box is empty after update attempt.";
        // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("No relevant instruments found to display.", 3000);
    }
}

// Updates the chart display based on current selections
void MainWindow::updateChart() {
    int instrumentIndex = ui->instrumentComboBox->currentIndex();
    int intervalIndex = ui->intervalComboBox->currentIndex();
    if (instrumentIndex < 0 || intervalIndex < 0 || !m_dataManager) { return; }

    QString instrumentToken = ui->instrumentComboBox->itemData(instrumentIndex).toString();
    QString interval = ui->intervalComboBox->itemData(intervalIndex).toString();
    QString instrumentName = ui->instrumentComboBox->currentText();
    qDebug() << "updateChart: Requesting chart update for" << instrumentName << "(" << instrumentToken << ")" << interval;

    QVector<CandleData> candles = m_dataManager->getStoredHistoricalData(instrumentToken, interval);
    qDebug() << "Retrieved" << candles.size() << "candles from DataManager for chart.";

    // --- TODO: Implement Chart Rendering Logic Here ---
    if (candles.isEmpty()) {
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage(QString("No data available for %1 %2").arg(instrumentName).arg(interval), 3000);
    } else {
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage(QString("Displaying %1 %2 (%3 candles)").arg(instrumentName).arg(interval).arg(candles.size()), 3000);
        // Render chart...
    }
    // --- End Chart Rendering TODO ---
}


// --- Login Flow Slots ---

// Handles the request to redirect the user for web login
void MainWindow::onRedirectUserForLogin(const QUrl& url) {
    qDebug() << "MainWindow::onRedirectUserForLogin: URL =" << url.toString();
    if (m_loginDialog && m_loginDialog->isVisible()) {
        qWarning() << "Login dialog is already visible.";
        m_loginDialog->activateWindow();
        return;
    }
    if (!m_loginDialog) {
        m_loginDialog = new LoginDialog(this);
        connect(m_loginDialog, &LoginDialog::requestTokenReceived, this, &MainWindow::handleLoginDialogSuccess, Qt::UniqueConnection);
        connect(m_loginDialog, &LoginDialog::loginFailed, this, &MainWindow::handleLoginDialogFailure, Qt::UniqueConnection);
        connect(m_loginDialog, &QDialog::finished, this, &MainWindow::handleLoginDialogFinished, Qt::UniqueConnection);
    }
    m_loginDialog->loadLoginPage(url);
    m_loginDialog->show();
    m_loginDialog->raise();
    m_loginDialog->activateWindow();
}

// --- LoginDialog Signal Handlers ---

// Slot connected to LoginDialog::requestTokenReceived
void MainWindow::handleLoginDialogSuccess(const QString& requestToken) {
    qDebug() << "MainWindow::handleLoginDialogSuccess: Token received.";
    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Login webpage success. Generating session...", 3000);
    if (m_kiteApi) {
        m_kiteApi->generateSession(requestToken);
    }
    if(m_loginDialog) {
        m_loginDialog->accept();
    }
}

// Slot connected to LoginDialog::loginFailed
void MainWindow::handleLoginDialogFailure(const QString& error) {
    qWarning() << "MainWindow::handleLoginDialogFailure: LoginDialog reported failure:" << error;
    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Login Failed (from webpage): " + error, 5000);
    QMessageBox::warning(this, "Login Failed", "Login failed on Zerodha page:\n" + error);
    ui->loginButton->setEnabled(true);
    if (m_loginDialog) {
        m_loginDialog->reject();
    }
}

// Slot connected to LoginDialog::finished
void MainWindow::handleLoginDialogFinished(int result) {
    qDebug() << "MainWindow::handleLoginDialogFinished: Dialog finished. Result code:" << result;
    LoginDialog* finishedDialog = m_loginDialog;
    m_loginDialog = nullptr;

    if (finishedDialog) {
        finishedDialog->deleteLater();
    }

    if (result != QDialog::Accepted) {
        if (m_kiteApi && m_kiteApi->getAccessToken().isEmpty()) {
             // *** MODIFIED *** Use showStatusMessage
            showStatusMessage("Login process cancelled or closed.", 3000);
            ui->loginButton->setEnabled(true);
        }
    }
}

// --- Kite API Signal Handlers ---

// *** REMOVED Duplicate onLoginFailed definition ***

// Handles session generation failure (signal from KiteConnectAPI) - Kept the first definition
void MainWindow::onLoginFailed(const QString &error) {
    qCritical() << "MainWindow::onLoginFailed (Session Generation Failed):" << error;
    QMessageBox::critical(this, "Login Failed", "Failed to generate API session:\n" + error);
    resetUserInfo(); // Clear user info and reset labels
    showStatusMessage("Login failed.", 5000); // Show error on status bar
    ui->loginButton->setEnabled(true);
    // Cleanup login dialog pointer if it exists (though finished should handle it)
    if (m_loginDialog) {
        qWarning() << "Login dialog pointer was not null during onLoginFailed! Clearing pointer.";
        m_loginDialog = nullptr;
    }
}


// Handles successful session generation -> schedules Profile request
void MainWindow::onLoginSuccessful(const QString &accessToken) {
    Q_UNUSED(accessToken);
    qDebug() << "MainWindow::onLoginSuccessful (Session Generated)";
    resetUserInfo();
    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("API session active. Scheduling profile fetch...", 3000);
    ui->loginButton->setEnabled(false);
    if (m_loginDialog) { m_loginDialog = nullptr; }

    qDebug() << "Scheduling user profile request with" << API_REQUEST_DELAY_MS << "ms delay.";
    QTimer::singleShot(API_REQUEST_DELAY_MS, this, &MainWindow::requestUserProfile);
}


// --- Profile/Margins/Instruments Sequence Slots ---

// Initiates the user profile request (called by timer)
void MainWindow::requestUserProfile() {
    if (!m_kiteApi) { qWarning("requestUserProfile: m_kiteApi is null"); return; }
    qDebug() << "MainWindow: Requesting user profile (after delay)...";
    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Fetching user profile...", 3000);
    m_kiteApi->fetchUserProfile();
}

// Handles successful profile fetch -> updates UI & schedules Margins request
void MainWindow::onUserProfileReceived(const QJsonObject& profileData)
{
    if (!m_kiteApi) { qWarning("onUserProfileReceived: m_kiteApi is null"); return; }
    qDebug() << "MainWindow: User Profile Received.";

    m_userName = profileData.value("user_name").toString("N/A");
    m_userId = profileData.value("user_id").toString("?");
    m_profileReceived = true;

    if (ui->statusLabel) {
        ui->statusLabel->setText(QString("User: %1 (%2)").arg(m_userName).arg(m_userId));
    }

    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Profile OK. Scheduling margins fetch...", 3000);
    qDebug() << "Scheduling user margins request with" << API_REQUEST_DELAY_MS << "ms delay.";
    QTimer::singleShot(API_REQUEST_DELAY_MS, this, &MainWindow::requestUserMargins);
}

// Initiates the user margins request (called by timer)
void MainWindow::requestUserMargins() {
    if (!m_kiteApi) { qWarning("requestUserMargins: m_kiteApi is null"); return; }
    qDebug() << "MainWindow: Requesting user margins (after delay)...";
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Fetching user margins...", 3000);
    m_kiteApi->fetchUserMargins();
}

// Handles successful margin fetch -> stores info, updates label, schedules Instruments request
void MainWindow::onUserMarginsReceived(const QJsonObject& marginData) {
    if (!m_kiteApi) { qWarning("onUserMarginsReceived: m_kiteApi is null"); return; }
    qDebug() << "MainWindow: User Margins Received OK.";

    m_availableFunds = 0.0;
    m_marginsReceived = false;
    if (marginData.contains("equity") && marginData["equity"].isObject()) {
        QJsonObject equityObj = marginData["equity"].toObject();
        if (equityObj.contains("available") && equityObj["available"].isObject()) {
            QJsonObject availableObj = equityObj["available"].toObject();
            if (availableObj.contains("live_balance") && availableObj["live_balance"].isDouble()) {
                m_availableFunds = availableObj["live_balance"].toDouble();
                m_marginsReceived = true;
            } else { qWarning("Could not find 'live_balance' (double) in equity->available margins."); }
        } else { qWarning("Could not find 'available' (object) in equity margins."); }
    } else { qWarning("Could not find 'equity' (object) in margins response."); }

    if (ui->fundsLabel) {
        if (m_marginsReceived) {
            QLocale currentLocale;
            QString fundsString = QString("Funds: â‚¹ %1").arg(currentLocale.toString(m_availableFunds, 'f', 2));
            ui->fundsLabel->setText(fundsString);
            qDebug() << "Updated Funds Label:" << fundsString;
        } else { ui->fundsLabel->setText("Funds: Error"); }
    } else { qWarning("fundsLabel UI element not found!"); }

    // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Margins OK. Scheduling instrument fetch...", 3000);
    QTimer::singleShot(API_REQUEST_DELAY_MS, this, &MainWindow::requestInstruments);
}

// Initiates the instrument fetch request (called by timer)
void MainWindow::requestInstruments() {
    if (!m_kiteApi) { qWarning("requestInstruments: m_kiteApi is null"); return; }
    qDebug() << "MainWindow: Requesting instrument fetch (after delay)...";
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Fetching instruments...", 3000);
    m_kiteApi->fetchAllInstruments();
}


// Handles failure during profile OR margin fetch - Stops sequence, resets labels
void MainWindow::onProfileOrMarginsFailed(const QString& context, const QString& error) {
    qCritical() << "MainWindow: Failed to fetch" << context << ":" << error;
    QMessageBox::critical(this, "API Error", QString("Failed to fetch user %1:\n%2").arg(context).arg(error));
    resetUserInfo();
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage(QString("Failed to fetch %1.").arg(context), 5000);
    ui->loginButton->setEnabled(true);
    qWarning() << "API call sequence halted due to" << context << "failure.";
}



// --- Data Flow Slots ---
// Handles successful instrument CSV download
void MainWindow::onInstrumentsFetched(const QString& filePath) {
    qDebug() << "MainWindow::onInstrumentsFetched: File downloaded to:" << filePath;
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Instruments downloaded. Processing...", 3000);
    if(m_dataManager) { m_dataManager->loadInstrumentsFromFile(filePath); }
    else { /* ... handle error ... */ }
}

// Handles instrument download failure
void MainWindow::onInstrumentsFetchFailed(const QString& error) {
    qCritical() << "MainWindow::onInstrumentsFetchFailed:" << error;
    QMessageBox::critical(this, "Data Error", "Failed to fetch instruments:\n" + error);
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Failed to fetch instruments.", 5000);
    resetUserInfo();
    ui->loginButton->setEnabled(true);
}

// Handles DataManager signal indicating instruments are loaded and ready
void MainWindow::onDataManagerReady() {
    qDebug() << "MainWindow::onDataManagerReady: DataManager reports instruments ready.";
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage("Instruments processed. Enqueuing data requests...", 3000);

    m_localInstrumentMap.clear();
    if (!m_dataManager) { /* ... handle error ... */ return; }

    QHash<QString, InstrumentData> allInstruments = m_dataManager->getAllInstruments();
    qDebug() << "Received" << allInstruments.count() << "total instruments from DataManager.";

    MarketCalendar* calendar = MarketCalendar::instance();
    if (!calendar) { /* ... handle error ... */ return; }
    QDate lastThursdayOfMonth = calendar->getLastThursdayOfMonth(QDate::currentDate().year(), QDate::currentDate().month());
    qDebug() << "Filtering for Indices and NFO Futures expiring:" << lastThursdayOfMonth.toString(Qt::ISODate);

    for (auto it = allInstruments.constBegin(); it != allInstruments.constEnd(); ++it) {
        const InstrumentData& inst = it.value();
        bool includeInstrument = false;
        if (inst.segment == "INDICES" && (inst.name == "NIFTY 50" || inst.name == "NIFTY BANK")) { includeInstrument = true; }
        else if (inst.segment == "NFO-FUT" && (inst.name == "NIFTY" || inst.name == "BANKNIFTY")) { if (inst.expiryDate.isValid() && inst.expiryDate == lastThursdayOfMonth) { includeInstrument = true; } }
        if (includeInstrument) { m_localInstrumentMap.insert(it.key(), inst); }
    }
    qDebug() << "Filtered down to" << m_localInstrumentMap.count() << "instruments locally for UI/requests.";

    updateInstrumentsTable();
    // Update user name label here as well, ensuring it persists
    if(m_profileReceived && ui->statusLabel) {
        ui->statusLabel->setText(QString("User: %1 (%2)").arg(m_userName).arg(m_userId));
    }

    enqueueHistoricalDataRequests();

    if (!m_historicalDataRequests.isEmpty()) { startHistoricalDataProcessing(); }
    else {
        qWarning() << "MainWindow::onDataManagerReady: No instruments match filtering criteria for historical data fetching.";
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("Instruments ready. No historical data needed.", 3000);
    }
}

// Handles historical data success -> schedules NEXT request using constant delay
void MainWindow::onHistoricalDataReceived(const QString& instrumentToken, const QString& interval, const QJsonArray& candles) {
    qDebug() << "MainWindow::onHistoricalDataReceived: Notified for" << instrumentToken << interval << "Count:" << candles.size();
    // Update chart if needed...
    int currentInstIndex = ui->instrumentComboBox->currentIndex();
    int currentIntvIndex = ui->intervalComboBox->currentIndex();
    if (currentInstIndex >= 0 && currentIntvIndex >= 0) {
         if (ui->instrumentComboBox->itemData(currentInstIndex).toString() == instrumentToken &&
             ui->intervalComboBox->itemData(currentIntvIndex).toString() == interval) {
             qDebug() << "Updating chart as received data matches selection.";
             updateChart();
         }
    }
    // Schedule the next request
    if (!m_historicalDataRequests.isEmpty()) {
        qDebug() << "Scheduling next historical data request after delay (" << API_REQUEST_DELAY_MS << "ms)";
        QTimer::singleShot(API_REQUEST_DELAY_MS, this, &MainWindow::processNextHistoricalDataRequest);
    } else {
        qDebug() << "Historical data queue empty after successful fetch. Stopping.";
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("Historical data fetching complete.", 5000);
    }
}

// Handles historical data fetch failure
void MainWindow::onHistoricalDataFailed(const QString& error, const QString& context) {
    qCritical() << "MainWindow::onHistoricalDataFailed: Context:" << context << "Error:" << error;
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage(QString("Error fetching data: %1").arg(context), 5000);

    // Schedule the next request even after failure
    if (!m_historicalDataRequests.isEmpty()) {
        qWarning() << "Scheduling next historical data request after failure (delay:" << API_REQUEST_DELAY_MS << "ms)";
        QTimer::singleShot(API_REQUEST_DELAY_MS, this, &MainWindow::processNextHistoricalDataRequest);
    } else {
        qDebug() << "Historical data queue empty after failed fetch. Stopping.";
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("Historical data fetching complete (with errors).", 5000);
    }
}

// --- Queue Processing ---
// Fills the historical data request queue based on the filtered local instrument map
void MainWindow::enqueueHistoricalDataRequests() {
    m_historicalDataRequests.clear();
    qDebug() << "Enqueuing historical data requests based on filtered local map (" << m_localInstrumentMap.count() << " instruments)...";
    if (m_localInstrumentMap.isEmpty()) { return; }

    for (auto it = m_localInstrumentMap.constBegin(); it != m_localInstrumentMap.constEnd(); ++it) {
        const QString& token = it.key();
        const InstrumentData& inst = it.value();
        // Enqueue 'day' and '5minute' requests only
        m_historicalDataRequests.enqueue({token, "day"});
        m_historicalDataRequests.enqueue({token, "5minute"});
        qDebug() << " Enqueuing day/5min for:" << inst.tradingSymbol << "(" << token << ")";
    }
    qDebug() << "Total historical data requests enqueued:" << m_historicalDataRequests.size();
}

// *** MODIFIED *** Kicks off the first request directly
void MainWindow::startHistoricalDataProcessing() {
    if (m_historicalDataRequests.isEmpty()) {
        qDebug() << "Historical data request queue is empty. Nothing to start.";
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("Instruments ready. No historical data to fetch.", 3000);
        return;
    }
    qDebug() << "Starting historical data request sequence...";
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage(QString("Fetching historical data (%1 requests)...").arg(m_historicalDataRequests.size()), 3000);
    processNextHistoricalDataRequest();
}

// Processes one historical data request from the queue (called initially and by singleShot timers)
void MainWindow::processNextHistoricalDataRequest() {
    if (m_historicalDataRequests.isEmpty()) {
        qDebug() << "Historical data queue is empty. Processing finished or nothing to process.";
        return;
    }
    HistoricalRequestInfo requestInfo = m_historicalDataRequests.dequeue();
    qDebug() << "Processing next historical data request: Token =" << requestInfo.instrumentToken << "Interval =" << requestInfo.interval << "[" << m_historicalDataRequests.size() << "left ]";
     // *** MODIFIED *** Use showStatusMessage
    showStatusMessage(QString("Requesting %1 %2 (%3 left)...").arg(requestInfo.instrumentToken).arg(requestInfo.interval).arg(m_historicalDataRequests.size()), 3000);

    if(m_dataManager) { m_dataManager->requestHistoricalData(requestInfo.instrumentToken, requestInfo.interval); }
    else {
        qCritical() << "DataManager is null! Cannot process historical data request for" << requestInfo.instrumentToken;
         // *** MODIFIED *** Use showStatusMessage
        showStatusMessage("Error: DataManager unavailable. Halting data fetch.", 5000);
        QMessageBox::critical(this, "Error", "DataManager unavailable. Halting historical data fetch.");
        m_historicalDataRequests.clear();
    }
}

// --- Helper Methods ---

// *** MODIFIED *** Shows message on the status bar
void MainWindow::showStatusMessage(const QString& message, int timeout /*= 0*/) {
    if (ui && ui->statusbar) {
        ui->statusbar->showMessage(message, timeout);
    } else {
         qWarning() << "Cannot show status message, UI or statusbar is null.";
         // Fallback: Log only if status bar isn't available
    }
    qDebug() << "Status Bar:" << message; // Log status updates
}

// Populates the interval selection combo box
void MainWindow::populateIntervalCombo() {
    ui->intervalComboBox->clear();
    // Add only required intervals
    ui->intervalComboBox->addItem("5 minute", "5minute"); // Display Text, Data Value
    ui->intervalComboBox->addItem("Day", "day");
    ui->intervalComboBox->setCurrentIndex(0); // Default to 5minute
}

// Populates the instrument combo box from the locally filtered map
void MainWindow::populateInstrumentCombo() {
    ui->instrumentComboBox->clear();
    qDebug() << "Populating Instrument ComboBox using local map (" << m_localInstrumentMap.count() << " items)...";
    if (m_localInstrumentMap.isEmpty()){ return; }

    QList<InstrumentData> sortedInstruments = m_localInstrumentMap.values();
    // Sort for display: Indices first, then alphabetical
    std::sort(sortedInstruments.begin(), sortedInstruments.end(), [](const InstrumentData& a, const InstrumentData& b){
        if (a.segment != b.segment) return a.segment < b.segment;
        return a.tradingSymbol < b.tradingSymbol;
    });

    for (const InstrumentData& inst : sortedInstruments) {
        ui->instrumentComboBox->addItem(inst.tradingSymbol, QVariant(inst.instrumentToken));
    }
    ui->instrumentComboBox->setEnabled(true);
    qDebug() << "Instrument ComboBox populated with" << ui->instrumentComboBox->count() << "items.";
}

// *** ADDED *** Helper to reset stored user info and UI labels
void MainWindow::resetUserInfo() {
    m_userName.clear();
    m_userId.clear();
    m_availableFunds = 0.0;
    m_profileReceived = false;
    m_marginsReceived = false;

    // Reset UI labels
    if (ui && ui->statusLabel) { ui->statusLabel->setText("User: N/A"); }
    if (ui && ui->fundsLabel) { ui->fundsLabel->setText("Funds: N/A"); }
}
